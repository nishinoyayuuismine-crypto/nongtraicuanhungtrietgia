<!DOCTYPE html>
<html lang="vi">
<head><meta charset="UTF-8">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>N√¥ng Tr·∫°i Tri·∫øt H·ªçc - Philosophy Farm</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Be Vietnam Pro', sans-serif;
      background: #87ceeb;
    }
    
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    #canvas-container {
      position: absolute;
      inset: 0;
      z-index: 0;
    }
    
    #ui-overlay {
      position: absolute;
      inset: 0;
      z-index: 10;
      display: flex;
      flex-direction: column;
      pointer-events: none;
    }
    
    #ui-overlay > * {
      pointer-events: auto;
    }
    
    /* Frosted Glass Effect */
    .glass-panel {
      background: rgba(15, 23, 42, 0.75);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-top: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .glass-card {
      background: rgba(15, 23, 42, 0.85);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 16px;
    }
    
    /* Health Bar */
    #health-bar-container {
      position: absolute;
      top: 16px;
      left: 16px;
      right: 16px;
      z-index: 20;
    }
    
    #health-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(15, 23, 42, 0.7);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border-radius: 8px;
      padding: 8px 16px;
    }
    
    #health-bar .progress-container {
      flex: 1;
      height: 12px;
      background: #374151;
      border-radius: 9999px;
      overflow: hidden;
    }
    
    #health-bar .progress-fill {
      height: 100%;
      transition: all 0.5s ease;
      border-radius: 9999px;
    }
    
    #health-bar span {
      color: white;
      font-size: 14px;
      font-weight: 500;
    }
    
    #health-bar .error-count {
      color: #f87171;
    }
    
    #health-bar .divider {
      color: #9ca3af;
    }
    
    /* Question Panel - Bottom 1/3 */
    #question-panel {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 33.333vh;
      display: flex;
      flex-direction: column;
      padding: 12px;
    }
    
    #question-text {
      color: white;
      font-size: 14px;
      font-weight: 500;
      text-align: center;
      line-height: 1.4;
      margin-bottom: 8px;
      min-height: 2.5rem;
    }
    
    #options-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      flex: 1;
      overflow: hidden;
    }
    
    .option-btn {
      position: relative;
      border-radius: 8px;
      border: 1px solid #475569;
      background: rgba(51, 65, 85, 0.8);
      color: white;
      text-align: left;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      overflow: hidden;
      font-family: 'Be Vietnam Pro', sans-serif;
      font-size: 12px;
      line-height: 1.3;
    }
    
    .option-btn:hover:not(:disabled) {
      background: rgba(71, 85, 105, 0.8);
      border-color: #64748b;
    }
    
    .option-btn:disabled {
      cursor: not-allowed;
    }
    
    .option-btn.correct {
      background: rgba(22, 163, 74, 0.9);
      border-color: #4ade80;
    }
    
    .option-btn.wrong {
      background: rgba(220, 38, 38, 0.9);
      border-color: #f87171;
    }
    
    .option-btn.dimmed {
      background: rgba(51, 65, 85, 0.8);
      border-color: #475569;
      color: #9ca3af;
    }
    
    .option-btn .letter {
      color: #4ade80;
      font-weight: 700;
      margin-right: 4px;
    }
    
    .option-btn .text {
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    /* Feedback Message */
    #feedback {
      text-align: center;
      font-size: 14px;
      font-weight: 500;
      margin-top: 8px;
    }
    
    #feedback.correct {
      color: #4ade80;
    }
    
    #feedback.wrong {
      color: #f87171;
    }
    
    /* Recovery Header */
    #recovery-header {
      text-align: center;
      margin-bottom: 8px;
    }
    
    #recovery-header .title {
      color: #f87171;
      font-weight: 700;
      font-size: 16px;
    }
    
    #recovery-header .subtitle {
      color: #9ca3af;
      font-size: 12px;
    }
    
    #recovery-dots {
      display: flex;
      justify-content: center;
      gap: 4px;
      margin-top: 4px;
    }
    
    #recovery-dots .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #4b5563;
    }
    
    #recovery-dots .dot.filled {
      background: #22c55e;
    }
    
    /* Center Panels (Start, Milestone, Victory, Defeat) */
    .center-panel {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    
    .center-card {
      padding: 32px;
      max-width: 400px;
      text-align: center;
    }
    
    .center-card h1 {
      color: white;
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .center-card h2 {
      font-size: 24px;
      font-weight: 700;
      margin-bottom: 8px;
    }
    
    .center-card h2.victory {
      color: #facc15;
    }
    
    .center-card h2.defeat {
      color: #f87171;
    }
    
    .center-card p {
      color: #d1d5db;
      margin-bottom: 16px;
    }
    
    .center-card .hint {
      color: #9ca3af;
      font-size: 14px;
    }
    
    .center-card .stats {
      color: #6b7280;
      font-size: 14px;
      margin-bottom: 24px;
    }
    
    /* Buttons */
    .btn-group {
      display: flex;
      gap: 16px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .btn {
      padding: 12px 24px;
      border-radius: 8px;
      border: none;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-family: 'Be Vietnam Pro', sans-serif;
    }
    
    .btn-green {
      background: #16a34a;
      color: white;
    }
    
    .btn-green:hover {
      background: #15803d;
    }
    
    .btn-amber {
      background: #d97706;
      color: white;
    }
    
    .btn-amber:hover {
      background: #b45309;
    }
    
    .btn-blue {
      background: #2563eb;
      color: white;
    }
    
    .btn-blue:hover {
      background: #1d4ed8;
    }
    
    .btn-slate {
      background: #475569;
      color: white;
    }
    
    .btn-slate:hover {
      background: #64748b;
    }
    
    .btn-stack {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    /* Back Button */
    #back-btn-container {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 20;
    }
    
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
      <!-- Start Screen -->
      <div id="start-screen" class="center-panel">
        <div class="glass-card center-card">
          <h1>Nong Trai Triet Hoc</h1>
          <p>Tra loi dung de nuoi duong sinh vat cua ban</p>
          <p class="hint">Chon con duong cua ban:</p>
          <div class="btn-group">
            <button class="btn btn-green" onclick="startGame('flora')">üå± Thuc vat</button>
            <button class="btn btn-amber" onclick="startGame('fauna')">üêî Dong vat</button>
          </div>
        </div>
      </div>
      
      <!-- Health Bar -->
      <div id="health-bar-container" class="hidden">
        <div id="health-bar">
          <span id="question-count">Q1/45</span>
          <div class="progress-container">
            <div class="progress-fill" id="health-fill" style="width: 100%; background: #22c55e;"></div>
          </div>
          <span id="health-percent">100%</span>
          <span class="divider">|</span>
          <span class="error-count">Loi: <span id="error-count">0</span></span>
        </div>
      </div>
      
      <!-- Question Panel -->
      <div id="question-panel" class="glass-panel hidden">
        <div id="recovery-header" class="hidden">
          <span class="title">Che do phuc hoi!</span>
          <p class="subtitle">Tra loi dung <span id="recovery-remaining">3</span> cau lien tiep de hoi sinh</p>
          <div id="recovery-dots">
            <div class="dot"></div>
            <div class="dot"></div>
            <div class="dot"></div>
          </div>
        </div>
        <p id="question-text"></p>
        <div id="options-grid"></div>
        <p id="feedback" class="hidden"></p>
      </div>
      
      <!-- Milestone Screen -->
      <div id="milestone-screen" class="center-panel hidden">
        <div class="glass-card center-card">
          <h2 class="victory">Cot moc tien hoa!</h2>
          <p>Ban da hoan thanh 25 cau hoi. Sinh vat cua ban da truong thanh!</p>
          <p class="hint">Ban muon:</p>
          <div class="btn-group">
            <button class="btn btn-amber" onclick="handleMilestone('harvest')">üéâ Thu hoach</button>
            <button class="btn btn-green" onclick="handleMilestone('evolve')">üå≥ Tien hoa</button>
          </div>
          <p class="stats" id="milestone-hint"></p>
        </div>
      </div>
      
      <!-- Victory Screen -->
      <div id="victory-screen" class="center-panel hidden">
        <div class="glass-card center-card">
          <h2 class="victory">Chien Thang!</h2>
          <p id="victory-message"></p>
          <p class="stats" id="victory-stats"></p>
          <div class="btn-stack">
            <button class="btn btn-blue" onclick="viewResult()">üëÅÔ∏è Xem thanh tuu</button>
            <button class="btn btn-green" onclick="saveImage()">üì• Tai ve hinh anh</button>
            <button class="btn btn-slate" onclick="restartGame()">üîÑ Choi lai</button>
          </div>
        </div>
      </div>
      
      <!-- Defeat Screen -->
      <div id="defeat-screen" class="center-panel hidden">
        <div class="glass-card center-card">
          <h2 class="defeat">That Bai</h2>
          <p>Sinh vat cua ban da khong the song sot...</p>
          <button class="btn btn-slate" onclick="restartGame()">üîÑ Thu lai</button>
        </div>
      </div>
    </div>
    
    <!-- Back Button (when viewing result) -->
    <div id="back-btn-container" class="hidden">
      <button class="btn btn-slate" onclick="hideResult()">‚Üê Quay lai</button>
    </div>
  </div>

  <script>
    // Questions data
    const questions = [
  {const questions = [
  {
    question: "Tri·∫øt h·ªçc ra ƒë·ªùi t·ª´ ngu·ªìn g·ªëc n√†o?",
    options: ["Ngu·ªìn g·ªëc nh·∫≠n th·ª©c v√† ngu·ªìn g·ªëc x√£ h·ªôi", "Ngu·ªìn g·ªëc t·ª± nhi√™n", "Ngu·ªìn g·ªëc t√¢m l√Ω", "Ngu·ªìn g·ªëc th·∫ßn tho·∫°i"],
    correct: 0
  },
  {
    question: "V·∫•n ƒë·ªÅ c∆° b·∫£n c·ªßa tri·∫øt h·ªçc l√† g√¨?",
    options: ["M·ªëi quan h·ªá gi·ªØa v·∫≠t ch·∫•t v√† √Ω th·ª©c", "V·∫•n ƒë·ªÅ con ng∆∞·ªùi", "V·∫•n ƒë·ªÅ x√£ h·ªôi", "V·∫•n ƒë·ªÅ t·ª± nhi√™n"],
    correct: 0
  },
  {
    question: "Th·∫ø gi·ªõi quan l√† g√¨?",
    options: ["H·ªá th·ªëng quan ƒëi·ªÉm v·ªÅ th·∫ø gi·ªõi v√† v·ªã tr√≠ con ng∆∞·ªùi", "C√°ch nh√¨n cu·ªôc s·ªëng", "S·ª± hi·ªÉu bi·∫øt khoa h·ªçc", "Ni·ªÅm tin t√¥n gi√°o"],
    correct: 0
  },
  {
    question: "ƒê·ªëi t∆∞·ª£ng c·ªßa Tri·∫øt h·ªçc M√°c-L√™nin l√† g√¨?",
    options: ["Quy lu·∫≠t chung nh·∫•t c·ªßa t·ª± nhi√™n, x√£ h·ªôi v√† t∆∞ duy", "Quy lu·∫≠t v·∫≠t l√Ω", "Quy lu·∫≠t kinh t·∫ø", "Quy lu·∫≠t t√¢m l√Ω"],
    correct: 0
  },
  {
    question: "V·∫≠t ch·∫•t l√† m·ªôt ph·∫°m tr√π tri·∫øt h·ªçc d√πng ƒë·ªÉ ch·ªâ th·ª±c t·∫°i kh√°ch quan - ƒê√¢y l√† ƒë·ªãnh nghƒ©a c·ªßa ai?",
    options: ["V.I. L√™nin", "C. M√°c", "Ph. ƒÇngghen", "H√™ghen"],
    correct: 0
  },
  {
    question: "H√¨nh th·ª©c v·∫≠n ƒë·ªông n√†o l√† cao nh·∫•t?",
    options: ["V·∫≠n ƒë·ªông x√£ h·ªôi", "V·∫≠n ƒë·ªông sinh h·ªçc", "V·∫≠n ƒë·ªông c∆° gi·ªõi", "V·∫≠n ƒë·ªông h√≥a h·ªçc"],
    correct: 0
  },
  {
    question: "Ngu·ªìn g·ªëc x√£ h·ªôi c·ªßa √Ω th·ª©c l√† g√¨?",
    options: ["Lao ƒë·ªông v√† ng√¥n ng·ªØ", "B·ªô √≥c ng∆∞·ªùi", "Th·∫ø gi·ªõi kh√°ch quan", "S·ª± ph·∫£n √°nh"],
    correct: 0
  },
  {
    question: "Quy lu·∫≠t n√†o v·∫°ch ra ph∆∞∆°ng th·ª©c c·ªßa s·ª± ph√°t tri·ªÉn?",
    options: ["Quy lu·∫≠t l∆∞·ª£ng - ch·∫•t", "Quy lu·∫≠t m√¢u thu·∫´n", "Quy lu·∫≠t ph·ªß ƒë·ªãnh", "Quy lu·∫≠t nh√¢n qu·∫£"],
    correct: 0
  },
  {
    question: "Quy lu·∫≠t n√†o l√† h·∫°t nh√¢n c·ªßa ph√©p bi·ªán ch·ª©ng?",
    options: ["Quy lu·∫≠t m√¢u thu·∫´n", "Quy lu·∫≠t l∆∞·ª£ng ch·∫•t", "Quy lu·∫≠t ph·ªß ƒë·ªãnh", "Quy lu·∫≠t m√¢u thu·∫´n x√£ h·ªôi"],
    correct: 0
  },
  {
    question: "Th·ª±c ti·ªÖn l√† g√¨?",
    options: ["Ho·∫°t ƒë·ªông v·∫≠t ch·∫•t - c·∫£m t√≠nh c√≥ m·ª•c ƒë√≠ch", "M·ªçi suy nghƒ© c·ªßa con ng∆∞·ªùi", "Ho·∫°t ƒë·ªông th√≠ nghi·ªám", "S·ª± quan s√°t"],
    correct: 0
  },
  {
    question: "Ph√©p bi·ªán ch·ª©ng duy v·∫≠t c√≥ m·∫•y nguy√™n l√Ω c∆° b·∫£n?",
    options: ["2 nguy√™n l√Ω", "3 nguy√™n l√Ω", "4 nguy√™n l√Ω", "6 nguy√™n l√Ω"],
    correct: 0
  },
  {
    question: "M·ªëi li√™n h·ªá ph·ªï bi·∫øn c√≥ t√≠nh ch·∫•t g√¨?",
    options: ["T√≠nh kh√°ch quan, ph·ªï bi·∫øn, ƒëa d·∫°ng", "T√≠nh ch·ªß quan", "T√≠nh nh·∫•t th·ªùi", "T√≠nh ƒë∆°n nh·∫•t"],
    correct: 0
  },
  {
    question: "C∆° s·ªü c·ªßa m·ªëi li√™n h·ªá ph·ªï bi·∫øn l√† g√¨?",
    options: ["T√≠nh th·ªëng nh·∫•t v·∫≠t ch·∫•t c·ªßa th·∫ø gi·ªõi", "√ù mu·ªën con ng∆∞·ªùi", "S·ª± s·∫Øp ƒë·∫∑t c·ªßa th·∫ßn linh", "T√≠nh ng·∫´u nhi√™n"],
    correct: 0
  },
  {
    question: "Ph√°t tri·ªÉn l√† g√¨?",
    options: ["S·ª± v·∫≠n ƒë·ªông ƒëi l√™n t·ª´ th·∫•p ƒë·∫øn cao", "S·ª± thay ƒë·ªïi v·ªã tr√≠", "S·ª± l·∫∑p l·∫°i c√°i c≈©", "S·ª± ƒë·ª©ng y√™n"],
    correct: 0
  },
  {
    question: "C√°i ri√™ng l√† ph·∫°m tr√π d√πng ƒë·ªÉ ch·ªâ c√°i g√¨?",
    options: ["M·ªôt s·ª± v·∫≠t, hi·ªán t∆∞·ª£ng nh·∫•t ƒë·ªãnh", "C√°c m·∫∑t gi·ªëng nhau", "C√°c ƒë·∫∑c ƒëi·ªÉm l·∫∑p l·∫°i", "T·ªïng th·ªÉ th·∫ø gi·ªõi"],
    correct: 0
  },
  {
    question: "C√°i chung t·ªìn t·∫°i ·ªü ƒë√¢u?",
    options: ["Trong c√°i ri√™ng", "Ngo√†i c√°i ri√™ng", "ƒê·ªôc l·∫≠p v·ªõi c√°i ri√™ng", "Trong t∆∞ duy con ng∆∞·ªùi"],
    correct: 0
  },
  {
    question: "Nguy√™n nh√¢n l√† g√¨?",
    options: ["S·ª± t√°c ƒë·ªông g√¢y ra s·ª± bi·∫øn ƒë·ªïi", "S·ª± ki·ªán x·∫£y ra tr∆∞·ªõc", "S·ª± ki·ªán x·∫£y ra sau", "S·ª± tr√πng h·ª£p"],
    correct: 0
  },
  {
    question: "T·∫•t nhi√™n l√† c√°i g√¨?",
    options: ["B·∫Øt ngu·ªìn t·ª´ b·∫£n ch·∫•t b√™n trong", "Do y·∫øu t·ªë b√™n ngo√†i", "S·ª± may m·∫Øn", "Kh√¥ng th·ªÉ d·ª± b√°o"],
    correct: 0
  },
  {
    question: "N·ªôi dung l√† g√¨?",
    options: ["T·ªïng h·ª£p t·∫•t c·∫£ nh·ªØng m·∫∑t, nh·ªØng y·∫øu t·ªë t·∫°o n√™n s·ª± v·∫≠t", "H√¨nh th·ª©c b√™n ngo√†i", "V·∫ª b·ªÅ ngo√†i", "C√°ch s·∫Øp x·∫øp"],
    correct: 0
  },
  {
    question: "Ch·∫•t l√† ph·∫°m tr√π d√πng ƒë·ªÉ ch·ªâ c√°i g√¨?",
    options: ["T√≠nh quy ƒë·ªãnh kh√°ch quan v·ªën c√≥", "S·ªë l∆∞·ª£ng c√°c m·∫∑t", "Tr·ªçng l∆∞·ª£ng s·ª± v·∫≠t", "M√†u s·∫Øc hi·ªán t∆∞·ª£ng"],
    correct: 0
  },
  {
    question: "L∆∞·ª£ng l√† ph·∫°m tr√π ch·ªâ c√°i g√¨?",
    options: ["Quy m√¥, tr√¨nh ƒë·ªô, s·ªë l∆∞·ª£ng", "B·∫£n ch·∫•t s·ª± v·∫≠t", "C·∫•u tr√∫c b√™n trong", "T√≠nh ch·∫•t ·ªïn ƒë·ªãnh"],
    correct: 0
  },
  {
    question: "ƒê·ªô l√† g√¨?",
    options: ["Gi·ªõi h·∫°n m√† s·ª± thay ƒë·ªïi v·ªÅ l∆∞·ª£ng ch∆∞a l√†m thay ƒë·ªïi v·ªÅ ch·∫•t", "ƒêi·ªÉm x·∫£y ra b∆∞·ªõc nh·∫£y", "S·ª± thay ƒë·ªïi ho√†n to√†n", "S·ª± ƒë·ª©ng y√™n"],
    correct: 0
  },
  {
    question: "M√¢u thu·∫´n l√† g√¨?",
    options: ["S·ª± th·ªëng nh·∫•t v√† ƒë·∫•u tranh c·ªßa c√°c m·∫∑t ƒë·ªëi l·∫≠p", "S·ª± c√£i nhau", "S·ª± kh√°c bi·ªát ho√†n to√†n", "S·ª± gi·ªëng nhau"],
    correct: 0
  },
  {
    question: "Ph·ªß ƒë·ªãnh bi·ªán ch·ª©ng l√† g√¨?",
    options: ["T·ª± ph·ªß ƒë·ªãnh, c√≥ t√≠nh k·∫ø th·ª´a", "X√≥a b·ªè ho√†n to√†n c√°i c≈©", "S·ª± t√°c ƒë·ªông t·ª´ b√™n ngo√†i", "S·ª± ph√° h·ªßy"],
    correct: 0
  },
  {
    question: "Nh·∫≠n th·ª©c l√† qu√° tr√¨nh g√¨?",
    options: ["Ph·∫£n √°nh nƒÉng ƒë·ªông, s√°ng t·∫°o th·ª±c t·∫°i", "S·ª± sao ch√©p m√°y m√≥c", "S·ª± t∆∞·ªüng t∆∞·ª£ng", "B·∫£n nƒÉng c·ªßa con ng∆∞·ªùi"],
    correct: 0
  },
  {
    question: "Nh·∫≠n th·ª©c c·∫£m t√≠nh g·ªìm nh·ªØng h√¨nh th·ª©c n√†o?",
    options: ["C·∫£m gi√°c, tri gi√°c, bi·ªÉu t∆∞·ª£ng", "Kh√°i ni·ªám, ph√°n ƒëo√°n", "Suy lu·∫≠n", "L√Ω thuy·∫øt"],
    correct: 0
  },
  {
    question: "Nh·∫≠n th·ª©c l√Ω t√≠nh g·ªìm nh·ªØng h√¨nh th·ª©c n√†o?",
    options: ["Kh√°i ni·ªám, ph√°n ƒëo√°n, suy lu·∫≠n", "C·∫£m gi√°c, tri gi√°c", "Bi·ªÉu t∆∞·ª£ng", "H√¨nh ·∫£nh"],
    correct: 0
  },
  {
    question: "Ch√¢n l√Ω l√† g√¨?",
    options: ["Tri th·ª©c ph√π h·ª£p v·ªõi th·ª±c t·∫ø", "ƒêi·ªÅu m·ªçi ng∆∞·ªùi tin theo", "L·ªùi n√≥i c·ªßa ng∆∞·ªùi gi√†u", "S·ª± t∆∞·ªüng t∆∞·ª£ng"],
    correct: 0
  },
  {
    question: "L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t g·ªìm nh·ªØng y·∫øu t·ªë n√†o?",
    options: ["Ng∆∞·ªùi lao ƒë·ªông v√† t∆∞ li·ªáu s·∫£n xu·∫•t", "M√°y m√≥c v√† nh√† x∆∞·ªüng", "Ti·ªÅn v·ªën", "C√¥ng ngh·ªá"],
    correct: 0
  },
  {
    question: "Quan h·ªá s·∫£n xu·∫•t g·ªìm nh·ªØng m·∫∑t n√†o?",
    options: ["S·ªü h·ªØu, t·ªï ch·ª©c, ph√¢n ph·ªëi", "Mua b√°n, trao ƒë·ªïi", "Vay v·ªën", "Ti√™u d√πng"],
    correct: 0
  }
  {
    question: "T·ªìn t·∫°i x√£ h·ªôi bao g·ªìm nh·ªØng y·∫øu t·ªë n√†o?",
    options: ["Ph∆∞∆°ng th·ª©c s·∫£n xu·∫•t, ƒëi·ªÅu ki·ªán t·ª± nhi√™n, d√¢n c∆∞", "VƒÉn h√≥a, ngh·ªá thu·∫≠t", "Ph√°p lu·∫≠t v√† t√¥n gi√°o", "Ch√≠nh tr·ªã v√† ƒë·∫°o ƒë·ª©c"],
    correct: 0
  },
  {
    question: "Y·∫øu t·ªë n√†o trong t·ªìn t·∫°i x√£ h·ªôi ƒë√≥ng vai tr√≤ quy·∫øt ƒë·ªãnh nh·∫•t?",
    options: ["Ph∆∞∆°ng th·ª©c s·∫£n xu·∫•t", "ƒêi·ªÅu ki·ªán t·ª± nhi√™n", "M·∫≠t ƒë·ªô d√¢n c∆∞", "ƒê·ªãa h√¨nh ƒë·ªãa l√Ω"],
    correct: 0
  },
  {
    question: "√ù th·ª©c x√£ h·ªôi l√† g√¨?",
    options: ["M·∫∑t tinh th·∫ßn c·ªßa ƒë·ªùi s·ªëng x√£ h·ªôi", "To√†n b·ªô c√°c quy ƒë·ªãnh ph√°p lu·∫≠t", "C√°c ho·∫°t ƒë·ªông vui ch∆°i gi·∫£i tr√≠", "Nhu c·∫ßu ƒÉn m·∫∑c c·ªßa con ng∆∞·ªùi"],
    correct: 0
  },
  {
    question: "M·ªëi quan h·ªá gi·ªØa t·ªìn t·∫°i x√£ h·ªôi v√† √Ω th·ª©c x√£ h·ªôi l√† g√¨?",
    options: ["T·ªìn t·∫°i x√£ h·ªôi quy·∫øt ƒë·ªãnh √Ω th·ª©c x√£ h·ªôi", "√ù th·ª©c x√£ h·ªôi quy·∫øt ƒë·ªãnh t·ªìn t·∫°i x√£ h·ªôi", "Hai y·∫øu t·ªë ho√†n to√†n ƒë·ªôc l·∫≠p", "√ù th·ª©c x√£ h·ªôi lu√¥n l·∫°c h·∫≠u h∆°n"],
    correct: 0
  },
  {
    question: "H√¨nh th√°i kinh t·∫ø - x√£ h·ªôi bao g·ªìm nh·ªØng y·∫øu t·ªë n√†o?",
    options: ["L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t, quan h·ªá s·∫£n xu·∫•t, ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng", "C√¥ng c·ª• lao ƒë·ªông v√† ƒë·∫•t ƒëai", "Nh√† n∆∞·ªõc v√† c√°c ƒë·∫£ng ph√°i", "VƒÉn h√≥a v√† √Ω th·ª©c"],
    correct: 0
  },
  {
    question: "Ti·∫øn tr√¨nh l·ªãch s·ª≠ - t·ª± nhi√™n c·ªßa x√£ h·ªôi lo√†i ng∆∞·ªùi l√† g√¨?",
    options: ["S·ª± thay th·∫ø c√°c h√¨nh th√°i kinh t·∫ø - x√£ h·ªôi t·ª´ th·∫•p ƒë·∫øn cao", "S·ª± thay ƒë·ªïi c·ªßa kh√≠ h·∫≠u", "S·ª± ti·∫øn h√≥a c·ªßa c√°c lo√†i sinh v·∫≠t", "S·ª± di c∆∞ c·ªßa c√°c b·ªô t·ªôc"],
    correct: 0
  },
  {
    question: "Giai c·∫•p l√† g√¨?",
    options: ["Nh·ªØng t·∫≠p ƒëo√†n ng∆∞·ªùi c√≥ ƒë·ªãa v·ªã kh√°c nhau trong h·ªá th·ªëng s·∫£n xu·∫•t", "Nh·ªØng ng∆∞·ªùi c√≥ c√πng s·ªü th√≠ch", "Nh·ªØng ng∆∞·ªùi c√πng ƒë·ªô tu·ªïi", "Nh·ªØng ng∆∞·ªùi c√πng t√¥n gi√°o"],
    correct: 0
  },
  {
    question: "Ngu·ªìn g·ªëc tr·ª±c ti·∫øp d·∫´n ƒë·∫øn s·ª± ra ƒë·ªùi c·ªßa giai c·∫•p l√† g√¨?",
    options: ["Ch·∫ø ƒë·ªô t∆∞ h·ªØu v·ªÅ t∆∞ li·ªáu s·∫£n xu·∫•t", "S·ª± ph√¢n c√¥ng lao ƒë·ªông", "Chi·∫øn tranh gi·ªØa c√°c b·ªô l·∫°c", "S·ª± kh√°c bi·ªát v·ªÅ tr√¨nh ƒë·ªô"],
    correct: 0
  },
  {
    question: "ƒê·∫•u tranh giai c·∫•p l√† g√¨?",
    options: ["Cu·ªôc ƒë·∫•u tranh gi·ªØa c√°c giai c·∫•p c√≥ l·ª£i √≠ch ƒë·ªëi l·∫≠p nhau", "S·ª± tranh lu·∫≠n v·ªÅ l√Ω thuy·∫øt", "Cu·ªôc c·∫°nh tranh trong kinh doanh", "S·ª± m√¢u thu·∫´n trong gia ƒë√¨nh"],
    correct: 0
  },
  {
    question: "Nh√† n∆∞·ªõc ra ƒë·ªùi t·ª´ khi n√†o?",
    options: ["Khi m√¢u thu·∫´n giai c·∫•p kh√¥ng th·ªÉ ƒëi·ªÅu h√≤a ƒë∆∞·ª£c", "Ngay t·ª´ th·ªùi k·ª≥ nguy√™n th·ªßy", "Khi con ng∆∞·ªùi bi·∫øt l√†m n√¥ng nghi·ªáp", "Khi c√≥ s·ª± xu·∫•t hi·ªán c·ªßa t√¥n gi√°o"],
    correct: 0
  },
  {
    question: "B·∫£n ch·∫•t c·ªßa nh√† n∆∞·ªõc l√† g√¨?",
    options: ["C√¥ng c·ª• th·ªëng tr·ªã c·ªßa giai c·∫•p n√†y ƒë·ªëi v·ªõi giai c·∫•p kh√°c", "T·ªï ch·ª©c b·∫£o v·ªá t·∫•t c·∫£ m·ªçi ng∆∞·ªùi", "M·ªôt t·ªï ch·ª©c thi·ªán nguy·ªán", "C∆° quan nghi√™n c·ª©u khoa h·ªçc"],
    correct: 0
  },
  {
    question: "C√°ch m·∫°ng x√£ h·ªôi l√† g√¨?",
    options: ["S·ª± thay ƒë·ªïi cƒÉn b·∫£n v·ªÅ ch·∫•t c·ªßa m·ªôt ch·∫ø ƒë·ªô x√£ h·ªôi", "S·ª± thay ƒë·ªïi m·ªôt s·ªë ng∆∞·ªùi ƒë·ª©ng ƒë·∫ßu nh√† n∆∞·ªõc", "Cu·ªôc c·∫£i c√°ch h√†nh ch√≠nh", "S·ª± thay ƒë·ªïi v·ªÅ k·ªπ thu·∫≠t s·∫£n xu·∫•t"],
    current: 0
  },
  {
    question: "Nguy√™n nh√¢n s√¢u xa c·ªßa c√°ch m·∫°ng x√£ h·ªôi l√† g√¨?",
    options: ["M√¢u thu·∫´n gi·ªØa l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t v√† quan h·ªá s·∫£n xu·∫•t", "Do mong mu·ªën c·ªßa c√°c nh√† l√£nh ƒë·∫°o", "Do t√°c ƒë·ªông c·ªßa c√°c y·∫øu t·ªë b√™n ngo√†i", "Do thi√™n tai v√† d·ªãch b·ªánh"],
    correct: 0
  },
  {
    question: "√ù th·ª©c c√° nh√¢n v√† √Ω th·ª©c x√£ h·ªôi quan h·ªá nh∆∞ th·∫ø n√†o?",
    options: ["√ù th·ª©c x√£ h·ªôi t·ªìn t·∫°i th√¥ng qua √Ω th·ª©c c√° nh√¢n", "√ù th·ª©c c√° nh√¢n ho√†n to√†n kh√°c √Ω th·ª©c x√£ h·ªôi", "√ù th·ª©c x√£ h·ªôi l·ªõn h∆°n √Ω th·ª©c c√° nh√¢n", "Hai kh√°i ni·ªám kh√¥ng li√™n quan"],
    correct: 0
  },
  {
    question: "Khoa h·ªçc tr·ªü th√†nh l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t tr·ª±c ti·∫øp t·ª´ khi n√†o?",
    options: ["T·ª´ cu·ªôc c√°ch m·∫°ng khoa h·ªçc k·ªπ thu·∫≠t hi·ªán ƒë·∫°i", "T·ª´ th·ªùi c·ªï ƒë·∫°i", "T·ª´ th·ªùi phong ki·∫øn", "T·ª´ th·∫ø k·ª∑ XVIII"],
    correct: 0
  },
  {
    question: "C√¥ng c·ª• lao ƒë·ªông l√† y·∫øu t·ªë nh∆∞ th·∫ø n√†o trong l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t?",
    options: ["Y·∫øu t·ªë ƒë·ªông nh·∫•t, c√°ch m·∫°ng nh·∫•t", "Y·∫øu t·ªë ƒë·ª©ng y√™n nh·∫•t", "Y·∫øu t·ªë kh√¥ng quan tr·ªçng", "Y·∫øu t·ªë mang t√≠nh tinh th·∫ßn"],
    correct: 0
  },
  {
    question: "Ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng bao g·ªìm y·∫øu t·ªë n√†o?",
    options: ["C√°c h√¨nh th√°i √Ω th·ª©c x√£ h·ªôi v√† c√°c thi·∫øt ch·∫ø t∆∞∆°ng ·ª©ng", "M√°y m√≥c v√† nh√† x∆∞·ªüng", "Nguy√™n li·ªáu s·∫£n xu·∫•t", "K·ªπ thu·∫≠t canh t√°c"],
    correct: 0
  },
  {
    question: "Quan h·ªá s·∫£n xu·∫•t ƒë√≥ng vai tr√≤ g√¨ ƒë·ªëi v·ªõi l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t?",
    options: ["T√°c ƒë·ªông tr·ªü l·∫°i (th√∫c ƒë·∫©y ho·∫∑c k√¨m h√£m) l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t", "Quy·∫øt ƒë·ªãnh s·ª± t·ªìn t·∫°i c·ªßa l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t", "Kh√¥ng c√≥ t√°c ƒë·ªông g√¨", "Thay th·∫ø l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t"],
    correct: 0
  },
  {
    question: "T√≠nh ƒë·ªôc l·∫≠p t∆∞∆°ng ƒë·ªëi c·ªßa √Ω th·ª©c x√£ h·ªôi th·ªÉ hi·ªán ·ªü ƒëi·ªÉm n√†o?",
    options: ["√ù th·ª©c x√£ h·ªôi c√≥ th·ªÉ v∆∞·ª£t tr∆∞·ªõc t·ªìn t·∫°i x√£ h·ªôi", "√ù th·ª©c x√£ h·ªôi lu√¥n ƒëi sau t·ªìn t·∫°i x√£ h·ªôi", "√ù th·ª©c x√£ h·ªôi kh√¥ng ph·ª• thu·ªôc v√†o con ng∆∞·ªùi", "√ù th·ª©c x√£ h·ªôi l√† b·∫•t bi·∫øn"],
    correct: 0
  },
  {
    question: "S·ª± ph·∫£n √°nh c·ªßa √Ω th·ª©c ƒë·ªëi v·ªõi v·∫≠t ch·∫•t l√† s·ª± ph·∫£n √°nh nh∆∞ th·∫ø n√†o?",
    options: ["Ph·∫£n √°nh nƒÉng ƒë·ªông, s√°ng t·∫°o", "Ph·∫£n √°nh nh∆∞ c√°i g∆∞∆°ng ch·ª•p ·∫£nh", "Ph·∫£n √°nh m√°y m√≥c", "Ph·∫£n √°nh th·ª• ƒë·ªông"],
    correct: 0
  },
  {
    question: "Y·∫øu t·ªë n√†o ƒë√≥ng vai tr√≤ l√† ph∆∞∆°ng th·ª©c t·ªìn t·∫°i c·ªßa v·∫≠t ch·∫•t?",
    options: ["V·∫≠n ƒë·ªông", "ƒê·ª©ng y√™n", "Tr·ªçng l∆∞·ª£ng", "M√†u s·∫Øc"],
    correct: 0
  },
  {
    question: "Ph√©p bi·ªán ch·ª©ng duy v·∫≠t l√† g√¨?",
    options: ["Khoa h·ªçc v·ªÅ nh·ªØng m·ªëi li√™n h·ªá ph·ªï bi·∫øn v√† s·ª± ph√°t tri·ªÉn", "Ngh·ªá thu·∫≠t tranh lu·∫≠n", "L√Ω thuy·∫øt v·ªÅ s·ª± tƒ©nh t·∫°i", "Ph∆∞∆°ng ph√°p quan s√°t th·ª±c ƒë·ªãa"],
    correct: 0
  },
  {
    question: "M·ªëi quan h·ªá bi·ªán ch·ª©ng l√† g√¨?",
    options: ["S·ª± t√°c ƒë·ªông qua l·∫°i, quy ƒë·ªãnh v√† chuy·ªÉn h√≥a l·∫´n nhau", "S·ª± x·∫øp c·∫°nh nhau c·ªßa c√°c s·ª± v·∫≠t", "S·ª± t√°ch r·ªùi nhau", "S·ª± tr√πng kh·ªõp ho√†n to√†n"],
    correct: 0
  },
  {
    question: "Ph√°t tri·ªÉn l√† m·ªôt tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát c·ªßa c√°i g√¨?",
    options: ["V·∫≠n ƒë·ªông", "ƒê·ª©ng y√™n", "Tho√°i h√≥a", "L·∫∑p l·∫°i"],
    correct: 0
  },
  {
    question: "C√°i chung ch·ªâ t·ªìn t·∫°i trong c√°i g√¨?",
    options: ["C√°i ri√™ng", "T∆∞ duy thu·∫ßn t√∫y", "Kh√¥ng gian tr·ªëng r·ªóng", "S√°ch v·ªü"],
    correct: 0
  },
  {
    question: "Hi·ªán t∆∞·ª£ng l√† g√¨?",
    options: ["S·ª± bi·ªÉu hi·ªán ra b√™n ngo√†i c·ªßa b·∫£n ch·∫•t", "C√°i n·∫±m s√¢u b√™n trong", "C√°i kh√¥ng bao gi·ªù thay ƒë·ªïi", "S·ª± t∆∞·ªüng t∆∞·ª£ng c·ªßa con ng∆∞·ªùi"],
    correct: 0
  },
  {
    question: "Kh·∫£ nƒÉng l√† ph·∫°m tr√π ph·∫£n √°nh c√°i g√¨?",
    options: ["C√°i ch∆∞a c√≥ nh∆∞ng s·∫Ω c√≥ khi c√≥ ƒë·ªß ƒëi·ªÅu ki·ªán", "C√°i ƒë√£ x·∫£y ra trong qu√° kh·ª©", "C√°i kh√¥ng bao gi·ªù c√≥ th·ªÉ th·ª±c hi·ªán", "C√°i ƒëang t·ªìn t·∫°i th·ª±c t·∫ø"],
    correct: 0
  },
  {
    question: "Lao ƒë·ªông l√† nh√¢n t·ªë nh∆∞ th·∫ø n√†o ƒë·ªëi v·ªõi s·ª± h√¨nh th√†nh √Ω th·ª©c?",
    options: ["Nh√¢n t·ªë quy·∫øt ƒë·ªãnh tr·ª±c ti·∫øp", "Nh√¢n t·ªë ph·ª• tr·ª£", "Nh√¢n t·ªë kh√¥ng quan tr·ªçng", "Nh√¢n t·ªë k√¨m h√£m"],
    correct: 0
  },
  {
    question: "Ng√¥n ng·ªØ ƒë√≥ng vai tr√≤ g√¨ ƒë·ªëi v·ªõi √Ω th·ª©c?",
    options: ["C√°i v·ªè v·∫≠t ch·∫•t c·ªßa t∆∞ duy", "N·ªôi dung c·ªßa t∆∞ duy", "S·ª± c·∫£n tr·ªü c·ªßa t∆∞ duy", "K·∫øt qu·∫£ c·ªßa t∆∞ duy"],
    correct: 0
  },
  {
    question: "Th·ª±c ti·ªÖn c√≥ m·∫•y h√¨nh th·ª©c c∆° b·∫£n?",
    options: ["3 h√¨nh th·ª©c", "2 h√¨nh th·ª©c", "4 h√¨nh th·ª©c", "5 h√¨nh th·ª©c"],
    correct: 0
  }
  {
    question: "Ti√™u chu·∫©n kh√°ch quan ƒë·ªÉ ph√¢n bi·ªát c√°c ch·∫ø ƒë·ªô x√£ h·ªôi trong l·ªãch s·ª≠ l√† g√¨?",
    options: ["H√¨nh th√°i kinh t·∫ø - x√£ h·ªôi", "√ù mu·ªën c·ªßa ng∆∞·ªùi ƒë·ª©ng ƒë·∫ßu", "Tr√¨nh ƒë·ªô vƒÉn h√≥a", "S·ªë l∆∞·ª£ng d√¢n c∆∞"],
    correct: 0
  },
  {
    question: "Y·∫øu t·ªë n√†o l√† c∆° s·ªü h·∫° t·∫ßng c·ªßa x√£ h·ªôi?",
    options: ["To√†n b·ªô nh·ªØng quan h·ªá s·∫£n xu·∫•t h·ª£p th√†nh c∆° c·∫•u kinh t·∫ø", "C√°c c√¥ng tr√¨nh x√¢y d·ª±ng", "H·ªá th·ªëng giao th√¥ng", "C√°c quan ƒëi·ªÉm ch√≠nh tr·ªã"],
    correct: 0
  },
  {
    question: "Quan h·ªá gi·ªØa c∆° s·ªü h·∫° t·∫ßng v√† ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng l√† quan h·ªá g√¨?",
    options: ["C∆° s·ªü h·∫° t·∫ßng quy·∫øt ƒë·ªãnh ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng", "Ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng quy·∫øt ƒë·ªãnh c∆° s·ªü h·∫° t·∫ßng", "Hai y·∫øu t·ªë kh√¥ng li√™n quan", "Quan h·ªá ph·ª• thu·ªôc ho√†n to√†n v√†o nh√† n∆∞·ªõc"],
    correct: 0
  },
  {
    question: "T√≠nh giai c·∫•p c·ªßa ki·∫øn tr√∫c th∆∞·ª£ng t·∫ßng th·ªÉ hi·ªán r√µ nh·∫•t ·ªü y·∫øu t·ªë n√†o?",
    options: ["Nh√† n∆∞·ªõc", "Ngh·ªá thu·∫≠t", "Ng√¥n ng·ªØ", "Khoa h·ªçc t·ª± nhi√™n"],
    correct: 0
  },
  {
    question: "S·ª± bi·∫øn ƒë·ªïi c·ªßa h√¨nh th√°i kinh t·∫ø - x√£ h·ªôi b·∫Øt ƒë·∫ßu t·ª´ s·ª± bi·∫øn ƒë·ªïi c·ªßa y·∫øu t·ªë n√†o?",
    options: ["L·ª±c l∆∞·ª£ng s·∫£n xu·∫•t", "Ph√°p lu·∫≠t", "T√¥n gi√°o", "ƒê·∫°o ƒë·ª©c"],
    correct: 0
  },
  {
    question: "Theo quan ƒëi·ªÉm c·ªßa M√°c, con ng∆∞·ªùi l√† g√¨?",
    options: ["T·ªïng h√≤a c√°c quan h·ªá x√£ h·ªôi", "M·ªôt th·ª±c th·ªÉ sinh h·ªçc thu·∫ßn t√∫y", "S·∫£n ph·∫©m c·ªßa th∆∞·ª£ng ƒë·∫ø", "M·ªôt th·ª±c th·ªÉ t√¢m linh"],
    correct: 0
  },
  {
    question: "L·ª±c l∆∞·ª£ng quy·∫øt ƒë·ªãnh s·ª± ph√°t tri·ªÉn c·ªßa l·ªãch s·ª≠ l√† ai?",
    options: ["Qu·∫ßn ch√∫ng nh√¢n d√¢n", "C√°c vƒ© nh√¢n, l√£nh t·ª•", "C√°c nh√† khoa h·ªçc", "C√°c nh√† t∆∞ t∆∞·ªüng"],
    correct: 0
  },
  {
    question: "T·∫°i sao qu·∫ßn ch√∫ng nh√¢n d√¢n l√† ng∆∞·ªùi s√°ng t·∫°o ch√¢n ch√≠nh ra l·ªãch s·ª≠?",
    options: ["H·ªç l√† l·ª±c l∆∞·ª£ng s·∫£n xu·∫•t v·∫≠t ch·∫•t c∆° b·∫£n", "H·ªç c√≥ s·ªë l∆∞·ª£ng ƒë√¥ng nh·∫•t", "H·ªç lu√¥n ƒëo√†n k·∫øt", "H·ªç c√≥ s·ª©c m·∫°nh c∆° b·∫Øp"],
    correct: 0
  },
  {
    question: "Vai tr√≤ c·ªßa l√£nh t·ª• ƒë·ªëi v·ªõi phong tr√†o qu·∫ßn ch√∫ng l√† g√¨?",
    options: ["ƒê·ªãnh h∆∞·ªõng, t·ªï ch·ª©c v√† th√∫c ƒë·∫©y phong tr√†o", "Thay th·∫ø ho√†n to√†n s·ª©c m·∫°nh qu·∫ßn ch√∫ng", "Kh√¥ng c√≥ vai tr√≤ g√¨ quan tr·ªçng", "Quy·∫øt ƒë·ªãnh thay cho l·ªãch s·ª≠"],
    correct: 0
  },
  {
    question: "B·∫£n ch·∫•t c·ªßa con ng∆∞·ªùi ƒë∆∞·ª£c h√¨nh th√†nh t·ª´ ƒë√¢u?",
    options: ["T·ª´ th·ª±c ti·ªÖn x√£ h·ªôi v√† c√°c quan h·ªá x√£ h·ªôi", "T·ª´ khi m·ªõi sinh ra trong gen", "Do m√¥i tr∆∞·ªùng t·ª± nhi√™n quy·∫øt ƒë·ªãnh", "Do s·ª± gi√°o d·ª•c thu·∫ßn t√∫y"],
    correct: 0
  },
  {
    question: "Gi·∫£i ph√≥ng con ng∆∞·ªùi theo tri·∫øt h·ªçc M√°c tr∆∞·ªõc h·∫øt l√† gi·∫£i ph√≥ng c√°i g√¨?",
    options: ["Gi·∫£i ph√≥ng v·ªÅ m·∫∑t kinh t·∫ø - x√£ h·ªôi", "Gi·∫£i ph√≥ng t∆∞ duy", "Gi·∫£i ph√≥ng ni·ªÅm tin", "Gi·∫£i ph√≥ng s·ª©c lao ƒë·ªông ch√¢n tay"],
    correct: 0
  },
  {
    question: "S·ª± ph·∫£n √°nh c·ªßa √Ω th·ª©c x√£ h·ªôi ƒë·ªëi v·ªõi t·ªìn t·∫°i x√£ h·ªôi c√≥ t√≠nh ch·∫•t g√¨?",
    options: ["T√≠nh ƒë·ªôc l·∫≠p t∆∞∆°ng ƒë·ªëi", "T√≠nh ph·ª• thu·ªôc tuy·ªát ƒë·ªëi", "T√≠nh m√°y m√≥c", "T√≠nh ng·∫´u nhi√™n"],
    correct: 0
  },
  {
    question: "T√¢m l√Ω x√£ h·ªôi l√† g√¨?",
    options: ["Nh·ªØng t√¨nh c·∫£m, ∆∞·ªõc mu·ªën, th√≥i quen h√¨nh th√†nh tr·ª±c ti·∫øp", "Nh·ªØng h·ªçc thuy·∫øt khoa h·ªçc", "C√°c quy ƒë·ªãnh c·ªßa nh√† n∆∞·ªõc", "S·ª± t∆∞·ªüng t∆∞·ª£ng c·ªßa c√° nh√¢n"],
    correct: 0
  },];
    

    // Game state
    let gameState = {
      screen: 'start', // start, playing, milestone, recovery, victory, defeat
      path: null, // flora, fauna
      questions: [],
      questionIndex: 0,
      health: 100,
      errors: 0,
      level: 1,
      recoveryCount: 0,
      selectedAnswer: null,
      showFeedback: false,
      lastCorrect: null,
      hideUI: false
    };

    let p5Instance = null;

    // Shuffle array
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[j], shuffled[i]] = [shuffled[i], shuffled[j]];
      }
      return shuffled;
    }

    // Initialize p5.js
    function initP5() {
      const sketch = (p) => {
        let time = 0;

        p.setup = () => {
          const canvas = p.createCanvas(window.innerWidth, window.innerHeight);
          canvas.parent('canvas-container');
          p.frameRate(30);
          p.noStroke();
        };

        p.windowResized = () => {
          p.resizeCanvas(window.innerWidth, window.innerHeight);
        };

        p.draw = () => {
          time += 0.02;
          const groundY = p.height * 0.67;
          const centerX = p.width / 2;

          // Sky
          p.background(135, 206, 235);

          // Ground (grass)
          p.noStroke();
          p.fill(34, 139, 34);
          p.rect(0, groundY - 10, p.width, 20);

          // Soil
          p.fill(101, 67, 33);
          p.rect(0, groundY + 10, p.width, p.height * 0.33);

          // Top soil strip
          p.fill(139, 90, 43);
          p.rect(0, groundY + 10, p.width, 15);

          // Sun
          p.fill(255, 220, 100);
          p.ellipse(p.width - 100, 80, 70, 70);
          p.fill(255, 240, 150, 100);
          p.ellipse(p.width - 100, 80, 90, 90);

          // Clouds
          p.fill(255, 255, 255, 200);
          drawCloud(p, 100 + Math.sin(time * 0.3) * 20, 60);
          drawCloud(p, 350 + Math.sin(time * 0.2) * 15, 100);
          drawCloud(p, p.width - 250 + Math.sin(time * 0.25) * 18, 75);

          // Draw entity if game is active
          if (gameState.path && gameState.screen !== 'start') {
            const progress = gameState.questionIndex;
            const healthVal = gameState.health;
            const isHealthy = healthVal > 50;
            const currentLevel = gameState.level;

            if (gameState.path === 'flora') {
              drawFlora(p, centerX, groundY, progress, isHealthy, currentLevel, time, gameState.errors);
            } else {
              drawFauna(p, centerX, groundY, progress, isHealthy, currentLevel, time, gameState.errors);
            }
          }
        };

        function drawCloud(p, x, y) {
          p.ellipse(x, y, 60, 40);
          p.ellipse(x + 25, y - 10, 50, 35);
          p.ellipse(x + 50, y, 55, 38);
          p.ellipse(x + 25, y + 10, 45, 30);
        }

        function drawFlora(p, centerX, groundY, progress, isHealthy, level, time, errorCount) {
          const windTime = time;

          function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
          }

          const treeDepth = Math.min(2 + Math.floor(progress / 5), level === 2 ? 10 : 7);
          const maxDepth = level === 2 ? 10 : 7;

          const showFlowers = progress >= 20;
          const showFruits = progress >= 25;
          const flowerCount = showFlowers ? Math.max(1, 5 - errorCount) : 0;
          const fruitCount = showFruits ? Math.max(1, 9 - errorCount) : 0;

          const branchTips = [];

          function drawBranch(worldX, worldY, angle, len, depth, branchIndex, seedOffset) {
            if (depth <= 0) return;

            const windOffset = Math.sin(windTime + branchIndex * 0.5) * 0.05 * (maxDepth - depth + 1);
            const currentAngle = angle + windOffset;

            const endX = worldX + Math.sin(currentAngle) * len;
            const endY = worldY - Math.cos(currentAngle) * len;

            const thickness = 2 + ((depth - 1) / (maxDepth - 1)) * (level === 2 ? 25 : 18);

            const brownVal = 60 + ((depth - 1) / (maxDepth - 1)) * 20;
            p.stroke(brownVal + 20, brownVal - 10, brownVal - 30);
            p.strokeWeight(thickness);
            p.line(worldX, worldY, endX, endY);

            if (depth <= 3) {
              branchTips.push({ x: endX, y: endY, depth: depth });

              const leafCount = Math.floor(15 - (depth - 1) * 3.3);
              for (let i = 0; i < leafCount; i++) {
                const seed = seedOffset + i * 100;
                const leafAngle = (seededRandom(seed) - 0.5) * Math.PI + currentAngle;
                const dist = 5 + seededRandom(seed + 1) * 25;
                const leafX = endX + Math.cos(leafAngle) * dist;
                const leafY = endY + Math.sin(leafAngle) * dist - 10;

                const leafSway = Math.sin(windTime * 1.5 + seed) * 4;

                p.push();
                p.translate(leafX + leafSway, leafY);
                p.rotate(leafAngle + Math.sin(windTime + seed) * 0.2);

                const g = 100 + seededRandom(seed + 3) * 100;
                p.fill(
                  isHealthy ? 30 + seededRandom(seed + 4) * 50 : 130 + seededRandom(seed + 4) * 30,
                  isHealthy ? g : 90 + seededRandom(seed + 3) * 50,
                  isHealthy ? 30 + seededRandom(seed + 5) * 50 : 30,
                  200
                );
                p.noStroke();
                p.ellipse(0, 0, 4 + seededRandom(seed + 6) * 7, 6 + seededRandom(seed + 7) * 9);
                p.pop();
              }
            }

            if (depth > 1) {
              const newLen = len * 0.72;
              const angleSpread = Math.PI / 5;

              const leftAngle = currentAngle - angleSpread + (seededRandom(seedOffset + 10) - 0.5) * 0.2;
              drawBranch(endX, endY, leftAngle, newLen, depth - 1, branchIndex * 2, seedOffset + 1000);

              const rightAngle = currentAngle + angleSpread + (seededRandom(seedOffset + 20) - 0.5) * 0.2;
              drawBranch(endX, endY, rightAngle, newLen, depth - 1, branchIndex * 2 + 1, seedOffset + 2000);

              if (depth > 3 && seededRandom(seedOffset + 30) > 0.5) {
                const midAngle = currentAngle + (seededRandom(seedOffset + 31) - 0.5) * 0.3;
                drawBranch(endX, endY, midAngle, newLen * 0.8, depth - 1, branchIndex * 3, seedOffset + 3000);
              }
            }
          }

          // Draw ground roots
          p.stroke(101, 67, 33);
          p.strokeWeight(level === 2 ? 6 : 3);
          p.noFill();
          for (let i = -2; i <= 2; i++) {
            const rootX = centerX + i * (level === 2 ? 20 : 12);
            const rootSway = Math.sin(windTime * 0.3 + i) * 2;
            p.bezier(
              rootX, groundY,
              rootX + i * 10 + rootSway, groundY + 20,
              rootX + i * 25 + rootSway, groundY + 35,
              rootX + i * 40, groundY + 50 + Math.abs(i) * 10
            );
          }

          const baseLen = Math.min(p.height * 0.15, level === 2 ? 140 : 100);
          drawBranch(centerX, groundY, 0, baseLen, treeDepth, 0, 42);

          // Draw flowers
          if (showFlowers && branchTips.length > 0) {
            p.noStroke();
            for (let i = 0; i < Math.min(flowerCount, branchTips.length); i++) {
              const tip = branchTips[i % branchTips.length];
              const flowerSway = Math.sin(windTime * 2 + i) * 3;

              p.push();
              p.translate(tip.x + flowerSway, tip.y - 15);
              p.rotate(windTime * 0.2 + i);

              p.fill(255, 220, 50);
              for (let j = 0; j < 5; j++) {
                const petalAngle = (j / 5) * Math.PI * 2;
                p.ellipse(Math.cos(petalAngle) * 8, Math.sin(petalAngle) * 8, 10, 10);
              }
              p.fill(255, 150, 50);
              p.ellipse(0, 0, 8, 8);
              p.pop();
            }
          }

          // Draw fruits
          if (showFruits && branchTips.length > 0) {
            for (let i = 0; i < Math.min(fruitCount, branchTips.length); i++) {
              const tip = branchTips[(i * 2 + flowerCount) % branchTips.length];
              const fruitSway = Math.sin(windTime + i * 0.7) * 2;

              p.push();
              p.translate(tip.x + fruitSway, tip.y + 5);

              p.stroke(100, 70, 40);
              p.strokeWeight(2);
              p.line(0, -10, 0, -2);

              const ripeness = (progress - 25) / 20;
              let r, g, b;
              if (ripeness < 0.3) { r = 100; g = 180; b = 80; }
              else if (ripeness < 0.7) { r = 255; g = 200; b = 50; }
              else { r = 220; g = 50; b = 30; }

              p.noStroke();
              p.fill(r, g, b);
              p.ellipse(0, 0, 18, 20);

              p.fill(255, 255, 255, 80);
              p.ellipse(-3, -4, 6, 6);

              p.fill(60, 130, 60);
              p.ellipse(0, -9, 10, 6);

              p.pop();
            }
          }
        }

        function drawFauna(p, centerX, groundY, progress, isHealthy, level, time, errorCount) {
          const breathe = Math.sin(time * 2) * 3;
          const isWeak = !isHealthy;
          const colorMult = isWeak ? 0.7 : 1;

          if (level === 1) {
            // CHICKEN lifecycle
            if (progress < 5) {
              // Egg stage
              const wobble = Math.sin(time * 6) * (2 + progress);
              const wobbleRotation = Math.sin(time * 6) * 0.1 * progress;

              p.push();
              p.translate(centerX, groundY - 30);
              p.rotate(wobbleRotation);

              p.fill(0, 0, 0, 30);
              p.ellipse(wobble * 0.3, 25, 45, 12);

              p.fill(255 * colorMult, 250 * colorMult, 240 * colorMult);
              p.stroke(200, 190, 180);
              p.strokeWeight(2);
              p.ellipse(0, 0, 38, 50);
              p.noStroke();

              if (progress >= 2) {
                p.stroke(120, 110, 100);
                p.strokeWeight(2);
                const crackProgress = (progress - 2) / 3;
                p.line(-8, -5, -8 + 10 * crackProgress, 8 * crackProgress);
                if (progress >= 3) {
                  p.line(5, -10, 5 - 6 * crackProgress, -10 + 12 * crackProgress);
                  p.line(-3, 5, -3 + 8 * crackProgress, 5 + 6 * crackProgress);
                }
                if (progress >= 4) {
                  p.fill(255, 220, 50);
                  p.noStroke();
                  p.ellipse(6, -8, 8, 6);
                }
                p.noStroke();
              }

              p.pop();
            } else if (progress < 15) {
              // Chick stage
              const chickSize = p.map(progress, 5, 15, 30, 60);
              const hop = Math.abs(Math.sin(time * 4)) * 5;
              const headBob = Math.sin(time * 3) * 3;
              const wingFlutter = Math.sin(time * 8) * 5;

              const bodyX = centerX;
              const bodyY = groundY - chickSize * 0.5 - hop;

              p.fill(0, 0, 0, 30);
              p.ellipse(bodyX, groundY - 5, chickSize * 0.8, 12);

              p.stroke(255 * colorMult, 180 * colorMult, 50);
              p.strokeWeight(3);
              const legSpread = Math.sin(time * 8) * 3;
              p.line(bodyX - 8 - legSpread, bodyY + chickSize * 0.3, bodyX - 10, groundY);
              p.line(bodyX + 8 + legSpread, bodyY + chickSize * 0.3, bodyX + 10, groundY);
              p.line(bodyX - 15, groundY, bodyX - 5, groundY);
              p.line(bodyX + 5, groundY, bodyX + 15, groundY);
              p.noStroke();

              p.fill(255 * colorMult, 220 * colorMult, 50);
              p.ellipse(bodyX, bodyY, chickSize, chickSize * 0.8);

              p.fill(255 * colorMult, 200 * colorMult, 30);
              p.push();
              p.translate(bodyX - chickSize * 0.3, bodyY);
              p.rotate(-0.3 + wingFlutter * 0.02);
              p.ellipse(0, 0, chickSize * 0.35, chickSize * 0.25);
              p.pop();

              p.push();
              p.translate(bodyX + chickSize * 0.3, bodyY);
              p.rotate(0.3 - wingFlutter * 0.02);
              p.ellipse(0, 0, chickSize * 0.35, chickSize * 0.25);
              p.pop();

              const headX = bodyX;
              const headY = bodyY - chickSize * 0.4 + headBob;
              p.fill(255 * colorMult, 220 * colorMult, 50);
              p.ellipse(headX, headY, chickSize * 0.55, chickSize * 0.5);

              p.fill(255 * colorMult, 150 * colorMult, 50);
              p.triangle(
                headX + chickSize * 0.2, headY,
                headX + chickSize * 0.4, headY + 3,
                headX + chickSize * 0.2, headY + 6
              );

              const blink = Math.sin(time * 0.5) > 0.95;
              p.fill(0);
              if (blink) {
                p.rect(headX + chickSize * 0.08 - 3, headY - 2, 6, 2);
              } else {
                p.ellipse(headX + chickSize * 0.08, headY - 2, 6, 6);
                p.fill(255);
                p.ellipse(headX + chickSize * 0.1, headY - 3, 2, 2);
              }
            } else {
              // Adult hen
              const henSize = p.map(progress, 15, 25, 70, 100);
              const waddle = Math.sin(time * 3) * 0.05;
              const headPeck = Math.sin(time * 2) * 8;
              const tailWag = Math.sin(time * 4) * 0.1;
              const wingRuffle = Math.sin(time * 6) * 3;

              const bodyX = centerX;
              const bodyY = groundY - henSize * 0.4 + breathe;

              p.fill(0, 0, 0, 30);
              p.ellipse(bodyX, groundY - 5, henSize * 1.2, 20);

              p.push();
              p.translate(bodyX, bodyY);
              p.rotate(waddle);

              p.push();
              p.rotate(tailWag);
              p.fill(100 * colorMult, 60 * colorMult, 30);
              p.ellipse(-henSize * 0.55, -henSize * 0.1, 35, 50);
              p.fill(80 * colorMult, 50 * colorMult, 25);
              p.ellipse(-henSize * 0.5, -henSize * 0.2, 25, 40);
              p.pop();

              p.fill(180 * colorMult, 100 * colorMult, 50);
              p.ellipse(0, 0, henSize, henSize * 0.65);

              p.fill(160 * colorMult, 90 * colorMult, 45);
              p.ellipse(-henSize * 0.05, wingRuffle * 0.3, henSize * 0.4, henSize * 0.35);

              p.stroke(255 * colorMult, 180 * colorMult, 50);
              p.strokeWeight(5);
              p.line(-15, henSize * 0.28, -15, henSize * 0.28 + 40 - breathe);
              p.line(15, henSize * 0.28, 15, henSize * 0.28 + 40 - breathe);
              p.noStroke();

              p.fill(255 * colorMult, 180 * colorMult, 50);
              p.ellipse(-15, henSize * 0.28 + 42 - breathe, 20, 8);
              p.ellipse(15, henSize * 0.28 + 42 - breathe, 20, 8);

              p.pop();

              const neckBaseX = bodyX + henSize * 0.35;
              const neckBaseY = bodyY - henSize * 0.15;

              p.push();
              p.translate(neckBaseX, neckBaseY);

              p.fill(180 * colorMult, 100 * colorMult, 50);
              p.ellipse(henSize * 0.1, -henSize * 0.1, henSize * 0.25, henSize * 0.35);

              const headX = henSize * 0.18 + headPeck * 0.1;
              const headY = -henSize * 0.28 + Math.abs(headPeck) * 0.05;

              p.fill(180 * colorMult, 100 * colorMult, 50);
              p.ellipse(headX, headY, henSize * 0.38, henSize * 0.35);

              p.fill(220 * colorMult, 50, 50);
              p.beginShape();
              p.vertex(headX - 8, headY - henSize * 0.15);
              p.vertex(headX - 3, headY - henSize * 0.25);
              p.vertex(headX + 3, headY - henSize * 0.15);
              p.vertex(headX + 8, headY - henSize * 0.25);
              p.vertex(headX + 12, headY - henSize * 0.12);
              p.endShape(p.CLOSE);

              p.ellipse(headX + 5, headY + henSize * 0.12, 10, 15);

              p.fill(255 * colorMult, 180 * colorMult, 50);
              p.triangle(
                headX + henSize * 0.15, headY - 2,
                headX + henSize * 0.28, headY + 3,
                headX + henSize * 0.15, headY + 8
              );

              const blink = Math.sin(time * 0.7) > 0.92;
              p.fill(0);
              if (blink) {
                p.rect(headX + 3, headY - 4, 7, 2);
              } else {
                p.ellipse(headX + 6, headY - 3, 7, 7);
                p.fill(255);
                p.ellipse(headX + 7, headY - 4, 2, 2);
              }

              p.pop();

              // Eggs after Q20
              if (progress >= 20) {
                const eggCount = Math.max(1, 5 - errorCount);
                for (let i = 0; i < eggCount; i++) {
                  const eggX = centerX - 90 + i * 35;
                  const eggWobble = Math.sin(time * 2 + i) * 1;

                  p.fill(0, 0, 0, 20);
                  p.ellipse(eggX, groundY - 3, 28, 8);

                  p.fill(255 * colorMult, 250 * colorMult, 240 * colorMult);
                  p.stroke(230, 220, 210);
                  p.strokeWeight(1);
                  p.ellipse(eggX + eggWobble, groundY - 16, 24, 30);
                  p.noStroke();
                }
              }
            }
          } else {
            // LEVEL 2: WATER BUFFALO
            const buffaloSize = p.map(progress - 25, 0, 20, 100, 180);
            const walkCycle = Math.sin(time * 2);
            const breatheDeep = Math.sin(time * 1.5) * 5;
            const tailSwing = Math.sin(time * 3) * 25;
            const earFlick = Math.sin(time * 4) * 0.15;
            const headNod = Math.sin(time * 1.2) * 3;

            const bodyX = centerX;
            const bodyY = groundY - buffaloSize * 0.4 + breatheDeep;

            p.fill(0, 0, 0, 40);
            p.ellipse(bodyX, groundY - 5, buffaloSize * 1.6, 30);

            // Tail
            p.stroke(30 * colorMult, 25 * colorMult, 20);
            p.strokeWeight(6);
            p.noFill();
            p.bezier(
              bodyX - buffaloSize * 0.7, bodyY,
              bodyX - buffaloSize * 0.8, bodyY + 30,
              bodyX - buffaloSize * 0.75 + tailSwing * 0.3, bodyY + 50,
              bodyX - buffaloSize * 0.7 + tailSwing, bodyY + 70
            );
            p.fill(20, 15, 10);
            p.noStroke();
            p.ellipse(bodyX - buffaloSize * 0.7 + tailSwing, bodyY + 75, 18, 25);

            // Legs
            const legOffset = walkCycle * 8;
            p.fill(40 * colorMult, 35 * colorMult, 30);
            p.rect(bodyX - buffaloSize * 0.45, bodyY + buffaloSize * 0.25 - legOffset, 25, buffaloSize * 0.5, 5);
            p.rect(bodyX - buffaloSize * 0.25, bodyY + buffaloSize * 0.25 + legOffset, 25, buffaloSize * 0.5, 5);
            p.rect(bodyX + buffaloSize * 0.15, bodyY + buffaloSize * 0.25 + legOffset, 25, buffaloSize * 0.5, 5);
            p.rect(bodyX + buffaloSize * 0.35, bodyY + buffaloSize * 0.25 - legOffset, 25, buffaloSize * 0.5, 5);

            // Hooves
            p.fill(20, 15, 10);
            p.ellipse(bodyX - buffaloSize * 0.45 + 12, groundY, 28, 12);
            p.ellipse(bodyX - buffaloSize * 0.25 + 12, groundY, 28, 12);
            p.ellipse(bodyX + buffaloSize * 0.15 + 12, groundY, 28, 12);
            p.ellipse(bodyX + buffaloSize * 0.35 + 12, groundY, 28, 12);

            // Body
            p.fill(50 * colorMult, 45 * colorMult, 40);
            p.ellipse(bodyX, bodyY, buffaloSize * 1.4, buffaloSize * 0.75);

            // Shoulder hump
            p.ellipse(bodyX + buffaloSize * 0.2, bodyY - buffaloSize * 0.25, buffaloSize * 0.5, buffaloSize * 0.4);

            // Neck
            const neckX = bodyX + buffaloSize * 0.55;
            const neckY = bodyY - buffaloSize * 0.1;
            p.ellipse(neckX, neckY, buffaloSize * 0.35, buffaloSize * 0.5);

            // Head
            const headX = neckX + buffaloSize * 0.2;
            const headY = neckY + headNod;

            p.fill(50 * colorMult, 45 * colorMult, 40);
            p.ellipse(headX, headY, buffaloSize * 0.45, buffaloSize * 0.38);

            // Horns
            p.stroke(70 * colorMult, 60 * colorMult, 50);
            p.strokeWeight(8);
            p.noFill();
            p.arc(headX - 25, headY - buffaloSize * 0.2, 60, 40, p.PI, p.PI * 2);
            p.arc(headX + 25, headY - buffaloSize * 0.2, 60, 40, p.PI, p.PI * 2);
            p.noStroke();

            // Ears
            p.fill(50 * colorMult, 45 * colorMult, 40);
            p.push();
            p.translate(headX - 30, headY - 15);
            p.rotate(-0.5 + earFlick);
            p.ellipse(0, 0, 20, 35);
            p.pop();

            p.push();
            p.translate(headX + 30, headY - 15);
            p.rotate(0.5 - earFlick);
            p.ellipse(0, 0, 20, 35);
            p.pop();

            // Muzzle
            p.fill(60 * colorMult, 55 * colorMult, 50);
            p.ellipse(headX + buffaloSize * 0.15, headY + buffaloSize * 0.08, 40, 30);

            // Nostrils
            p.fill(30, 25, 20);
            p.ellipse(headX + buffaloSize * 0.12, headY + buffaloSize * 0.12, 10, 8);
            p.ellipse(headX + buffaloSize * 0.2, headY + buffaloSize * 0.12, 10, 8);

            // Eyes
            const blink = Math.sin(time * 0.6) > 0.93;
            p.fill(20, 15, 10);
            if (blink) {
              p.rect(headX - 8, headY - 8, 12, 3);
              p.rect(headX + 20, headY - 8, 12, 3);
            } else {
              p.ellipse(headX - 2, headY - 5, 12, 12);
              p.ellipse(headX + 26, headY - 5, 12, 12);
              p.fill(255);
              p.ellipse(headX, headY - 6, 4, 4);
              p.ellipse(headX + 28, headY - 6, 4, 4);
            }

            // Calf after Q35
            if (progress >= 35) {
              const calfSize = 55;
              const calfX = centerX - 130;
              const calfY = groundY - calfSize * 0.35;
              const calfHop = Math.abs(Math.sin(time * 3)) * 8;
              const calfHeadTilt = Math.sin(time * 2) * 5;

              p.fill(0, 0, 0, 25);
              p.ellipse(calfX, groundY - 3, calfSize * 1.2, 15);

              p.fill(60 * colorMult, 55 * colorMult, 50);
              p.rect(calfX - 20, calfY - calfHop + 15, 10, 30, 3);
              p.rect(calfX + 10, calfY - calfHop + 15, 10, 30, 3);

              p.fill(60 * colorMult, 55 * colorMult, 50);
              p.ellipse(calfX, calfY - calfHop, calfSize, calfSize * 0.55);

              p.ellipse(calfX + calfSize * 0.35, calfY - calfHop - 5 + calfHeadTilt, calfSize * 0.35, calfSize * 0.3);

              p.ellipse(calfX + calfSize * 0.25, calfY - calfHop - 18 + calfHeadTilt, 10, 18);
              p.ellipse(calfX + calfSize * 0.45, calfY - calfHop - 18 + calfHeadTilt, 10, 18);

              p.fill(20, 15, 10);
              p.ellipse(calfX + calfSize * 0.4, calfY - calfHop - 6 + calfHeadTilt, 6, 6);
            }
          }
        }

        p.saveImage = () => {
          p.saveCanvas('nong-trai-triet-hoc', 'png');
        };
      };

      p5Instance = new p5(sketch);
    }

    // UI Functions
    function showScreen(screenId) {
      const screens = ['start-screen', 'milestone-screen', 'victory-screen', 'defeat-screen'];
      screens.forEach(id => {
        document.getElementById(id).classList.add('hidden');
      });
      if (screenId) {
        document.getElementById(screenId).classList.remove('hidden');
      }
    }

    function updateHealthBar() {
      document.getElementById('question-count').textContent = `Q${gameState.questionIndex + 1}/45`;
      document.getElementById('health-percent').textContent = `${gameState.health}%`;
      document.getElementById('error-count').textContent = gameState.errors;
      
      const fill = document.getElementById('health-fill');
      fill.style.width = `${gameState.health}%`;
      
      if (gameState.health > 50) {
        fill.style.background = '#22c55e';
      } else if (gameState.health > 25) {
        fill.style.background = '#eab308';
      } else {
        fill.style.background = '#ef4444';
      }
    }

    function renderQuestion() {
      const q = gameState.questions[gameState.questionIndex];
      document.getElementById('question-text').textContent = q.question;
      
      const grid = document.getElementById('options-grid');
      grid.innerHTML = '';
      
      q.options.forEach((option, idx) => {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.innerHTML = `<span class="letter">${String.fromCharCode(65 + idx)}.</span><span class="text">${option}</span>`;
        btn.onclick = () => handleAnswer(idx);
        grid.appendChild(btn);
      });
    }

    function updateRecoveryHeader() {
      const remaining = 3 - gameState.recoveryCount;
      document.getElementById('recovery-remaining').textContent = remaining;
      
      const dots = document.querySelectorAll('#recovery-dots .dot');
      dots.forEach((dot, i) => {
        dot.classList.toggle('filled', i < gameState.recoveryCount);
      });
    }

    // Game Functions
    function startGame(selectedPath) {
      gameState.path = selectedPath;
      gameState.questions = shuffleArray(questions).slice(0, 45);
      gameState.questionIndex = 0;
      gameState.health = 100;
      gameState.errors = 0;
      gameState.level = 1;
      gameState.recoveryCount = 0;
      gameState.screen = 'playing';
      gameState.hideUI = false;

      showScreen(null);
      document.getElementById('health-bar-container').classList.remove('hidden');
      document.getElementById('question-panel').classList.remove('hidden');
      document.getElementById('recovery-header').classList.add('hidden');
      
      updateHealthBar();
      renderQuestion();
    }

    function handleAnswer(answerIndex) {
      if (gameState.showFeedback) return;

      gameState.selectedAnswer = answerIndex;
      gameState.showFeedback = true;

      const q = gameState.questions[gameState.questionIndex];
      const isCorrect = answerIndex === q.correct;
      gameState.lastCorrect = isCorrect;

      // Update button styles
      const buttons = document.querySelectorAll('.option-btn');
      buttons.forEach((btn, idx) => {
        btn.disabled = true;
        if (idx === q.correct) {
          btn.classList.add('correct');
        } else if (idx === answerIndex && !isCorrect) {
          btn.classList.add('wrong');
        } else {
          btn.classList.add('dimmed');
        }
      });

      // Show feedback
      const feedback = document.getElementById('feedback');
      feedback.classList.remove('hidden', 'correct', 'wrong');
      feedback.classList.add(isCorrect ? 'correct' : 'wrong');
      feedback.textContent = isCorrect 
        ? (gameState.path === 'flora' ? 'Chinh xac! Cay dang lon len!' : 'Chinh xac! Sinh vat dang phat trien!')
        : 'Sai roi! Hay co gang nhe!';

      if (gameState.screen === 'recovery') {
        if (isCorrect) {
          gameState.recoveryCount++;
          updateRecoveryHeader();
          if (gameState.recoveryCount >= 3) {
            gameState.health = 30;
            gameState.screen = 'playing';
            gameState.recoveryCount = 0;
            document.getElementById('recovery-header').classList.add('hidden');
          }
        } else {
          gameState.recoveryCount = 0;
          updateRecoveryHeader();
        }
      } else {
        if (!isCorrect) {
          gameState.health = Math.max(0, gameState.health - 20);
          gameState.errors++;
          updateHealthBar();

          if (gameState.health <= 0) {
            setTimeout(() => {
              gameState.screen = 'recovery';
              gameState.recoveryCount = 0;
              gameState.showFeedback = false;
              gameState.selectedAnswer = null;
              
              document.getElementById('recovery-header').classList.remove('hidden');
              updateRecoveryHeader();
              renderQuestion();
              document.getElementById('feedback').classList.add('hidden');
            }, 1500);
            return;
          }
        }
      }

      setTimeout(() => {
        gameState.showFeedback = false;
        gameState.selectedAnswer = null;
        gameState.lastCorrect = null;
        document.getElementById('feedback').classList.add('hidden');

        const nextIndex = gameState.questionIndex + 1;

        // Milestone at Q25
        if (nextIndex === 25 && gameState.level === 1) {
          gameState.questionIndex = 25;
          gameState.screen = 'milestone';
          
          document.getElementById('health-bar-container').classList.add('hidden');
          document.getElementById('question-panel').classList.add('hidden');
          document.getElementById('milestone-hint').textContent = gameState.path === 'flora' 
            ? 'Tien hoa thanh cay co thu (ca phe/nhan)'
            : 'Tien hoa thanh trau nuoc';
          showScreen('milestone-screen');
          return;
        }

        // Victory at Q45
        if (nextIndex >= 45) {
          gameState.screen = 'victory';
          
          document.getElementById('health-bar-container').classList.add('hidden');
          document.getElementById('question-panel').classList.add('hidden');
          
          let message = '';
          if (gameState.path === 'flora') {
            message = gameState.level === 2 
              ? 'Cay co thu cua ban da phat trien hung vi!'
              : 'Cay ca chua cua ban da ra qua!';
          } else {
            message = gameState.level === 2
              ? 'Trau cua ban da truong thanh manh me!'
              : 'Ga cua ban da de trung!';
          }
          document.getElementById('victory-message').textContent = message;
          document.getElementById('victory-stats').textContent = `Hoan thanh voi ${gameState.errors} loi | Cap do ${gameState.level}`;
          showScreen('victory-screen');
          return;
        }

        gameState.questionIndex = nextIndex;
        updateHealthBar();
        renderQuestion();
      }, 1500);
    }

    function handleMilestone(choice) {
      if (choice === 'harvest') {
        gameState.screen = 'victory';
        
        let message = gameState.path === 'flora' 
          ? 'Cay ca chua cua ban da ra qua!'
          : 'Ga cua ban da de trung!';
        document.getElementById('victory-message').textContent = message;
        document.getElementById('victory-stats').textContent = `Hoan thanh voi ${gameState.errors} loi | Cap do ${gameState.level}`;
        showScreen('victory-screen');
      } else {
        gameState.level = 2;
        gameState.screen = 'playing';
        
        showScreen(null);
        document.getElementById('health-bar-container').classList.remove('hidden');
        document.getElementById('question-panel').classList.remove('hidden');
        renderQuestion();
      }
    }

    function restartGame() {
      window.location.reload();
    }

    function saveImage() {
      if (p5Instance && p5Instance.saveImage) {
        p5Instance.saveImage();
      }
    }

    function viewResult() {
      gameState.hideUI = true;
      document.getElementById('ui-overlay').classList.add('hidden');
      document.getElementById('back-btn-container').classList.remove('hidden');
    }

    function hideResult() {
      gameState.hideUI = false;
      document.getElementById('ui-overlay').classList.remove('hidden');
      document.getElementById('back-btn-container').classList.add('hidden');
    }

    // Initialize
    window.onload = () => {
      initP5();
    };
  </script>
</body>
</html>
